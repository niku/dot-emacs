#  -*- coding: utf-8 -*-

* Global stuff

** better-defaults
  [[https://github.com/technomancy/better-defaults][better-defaults]] does a bunch of generic emacs interface tidying,
  including:
  - better buffer unique names
  - turn off scrollbar, menu bar, toolbar
#+begin_src emacs-lisp
  (maybe-install-and-require 'better-defaults)
#+end_src

*** TODO check on backup directory duplication?

    better-defaults apparently now ensures backup files go into
    ~/.emacs.d; check if [[file:../init.el::backup-directory-alist%20`(("."%20.%20,(concat%20user-emacs-directory%20"backups"))))][my config]] is therefore redundant

** ido

  ido-ubiquitous enables ido in many places.  (better-defaults already
  enables ido for some things, this just goes further).  smex adds
  ido-like behaviour to =M-x=.
#+begin_src emacs-lisp
  (maybe-install-and-require 'ido-ubiquitous)
  (ido-mode t)
  (ido-ubiquitous-mode t)

  (maybe-install-and-require 'smex)
  (setq smex-save-file (concat user-emacs-directory ".smex-items"))
  (smex-initialize)
  (global-set-key (kbd "M-x") 'smex)
#+end_src

** magit

  [[https://github.com/magit/magit][magit]] is the only way to interact with git.  Seriously, even when
  I'm using other editors, I'll keep emacs open in order to use magit.
  The main reasons I like it:
  - easy manipulation of individual lines within a changeset
  - one-character commands for all common operations (push, pull,
    commit, rebase, merge..)
  As a result, I bind a global key combination to =magit-status= so
  it's always easy to get to.

#+begin_src emacs-lisp
  (maybe-install-and-require 'magit)
  (global-set-key "\C-cg" 'magit-status)
#+end_src

** exec-path-from-shell

   This is a little package that initializes emacs's =exec-path=
   variable from whatever your shell's =$PATH= is.

#+begin_src emacs-lisp
  (maybe-install-and-require 'exec-path-from-shell)
  (exec-path-from-shell-initialize)
#+end_src

** misc settings

*** y-or-n-p

   This replaces dialogs which require a full "yes" or "no" to just
   require a simple "y" or "n".

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** indicate empty lines

    This adds a graphic in the margin to show how many empty lines you
    have beyond the end of your file's content.

#+begin_src emacs-lisp
  (set-default 'indicate-empty-lines t)
#+end_src

* Lisp stuff

** Clojure

   [[https://github.com/clojure-emacs/cider][cider]] is a package for live-coding Clojure by interacting with a
   Clojure nREPL instance.  [[https://github.com/clojure-emacs/clojure-mode][clojure-mode]] is the major mode for editing
   clojure code.

#+begin_src emacs-lisp
  (maybe-install-and-require 'cider)
  (maybe-install-and-require 'clojure-mode)
#+end_src

   Files ending with =.clj= will automatically use clojure-mode, but
   =.cljs= seems to need configuration:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\.cljs$" . clojure-mode))
#+end_src

** Pretty lambdas

   Font-lock stuff to display character sequences such as =lambda= as
   unicode chars such as λ.

   First, we define the font-lock function to detect the appropriate
   sequence and what to replace it with:

#+begin_src emacs-lisp
  (defun pretty-lambdas ()
    (font-lock-add-keywords
     nil `(("\\(\\<lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))
#+end_src

   Then we add it to some lisp modes:

#+begin_src emacs-lisp
  (add-hook 'clojure-mode-hook #'pretty-lambdas)
  (add-hook 'scheme-mode-hook #'pretty-lambdas)
#+end_src

** Paredit

   Paredit is a minor mode for enforcing balanced parentheses and
   providing operations on sets of parentheses -- generally "slurp"
   and "barf" to swallow or remove terms at the right-hand side of a
   paren pair.  Naturally, this is a good fit for lisps.

   I'm not entirely sure I understand the =autoload= line here.  I
   think I cribbed it from somewhere on the internet.

#+begin_src emacs-lisp
  (maybe-install-and-require 'paredit)
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'clojure-mode-hook #'enable-paredit-mode)
  (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook #'enable-paredit-mode)
#+end_src

* Haskell

** Haskell mode

#+begin_src emacs-lisp
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
#+end_src

** Pretty arrows

   Font-lock stuff:

   - =->= (used in function types) gets turned into →
   - =<-= (used in do-notation) gets turned into ←
   - =\= gets turned into λ

#+begin_src emacs-lisp
  (defun pretty-arrows ()
    (font-lock-add-keywords
     nil `(("\\(->\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      8594 ;; unicode RIGHT ARROW
                                      ))))
           ("\\(<-\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      8592 ;; unicode LEFT ARROW
                                      ))))
           ("\\(\\\\\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      955 ;; unicode GREEK SMALL LETTER LAMBDA
                                      )))))))

  (add-hook 'haskell-mode-hook #'pretty-arrows)
#+end_src


* puppet

  [[https://docs.puppetlabs.com/puppet/][Puppet]] is a configuration management language.  First, we want the
  major mode for editing puppet code:

#+begin_src emacs-lisp
  (maybe-install-and-require 'puppet-mode)
#+end_src

  When we edit =.pp= files, we want to automatically run puppet-mode:

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\.pp$" . puppet-mode))
#+end_src

* Markdown

#+begin_src emacs-lisp
  (maybe-install-and-require 'markdown-mode)
#+end_src

